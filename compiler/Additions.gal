comment 'Additions.gal';

syntax My my
{
    alias self i;
    method void Attributes
    {
        comment 'look up the first argument in the parent context to know that it is a list.';
        entity Argument (list.shift [my Listargs]);
        string Property [. Argument Input];
        entity Definition (i Lookup Property);
        returnif (not Definition);
        string Data_Type [. Definition Data_Type];
        returnif (not Data_Type);
        .= Argument Data_Type Data_Type;
        my= Data_Type Data_Type;
    }
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code '[. self';
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ']';
        my= Fallback Gal_Code;
    }
}

operation Firstchar firstchar Unary
{
    argument String_Value;
    comment fallback '(substring ' [my String_Value Fallback] ' 0 1)';
    python [my String_Value Python] '[0]';
    javascript [my String_Value Javascript] '.charAt(0)';
}
operation Lastchar lastchar Unary
{
    argument String_Value;
    comment fallback '(substring ' [my String_Value Fallback] ' (- (length ' [my String_Value Fallback] ')) 1)';
    python [my String_Value Python] '[-1]';
    javascript [my String_Value Javascript] '.charAt(' [my String_Value Javascript] '.length-1)';
}

operation I i Invocation
{
    alias self;
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code '(. self';
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ')';
        my= Fallback Gal_Code;
    }
}


statement I i Invocation
{
    alias self;
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code '. self';
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ';';
        my= Fallback Gal_Code;
    }
}

statement Entity_New entity.new
{
    argument Variable;
    argument Class;
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code 'entity ' [my Variable Fallback] ' (new ' [my Class Fallback];
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ');';
        my= Fallback Gal_Code;
    }
}

statement Contif continue.if Line
{
    alias contif;
    argument Condition;
    fallback 'if ' [my Condition Fallback, line]
        '{' [line,
        indent] 'continue;' [line]
        '}';
}

statement Breakif break.if Line
{
    alias breakif;
    argument Condition;
    fallback 'if ' [my Condition Fallback, line]
        '{' [line,
        indent] 'break;' [line]
        '}';
}

statement Alias alias Line
{
    method void Fallback_Generate
    {
        string Code 'class.property string Aliases "';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Code ' ' [. Argument Fallback];
        }
        append Code ' ";';
        my= Fallback Code;
    }
}

statement Append append Append_Args
{
    alias string.append;
    argument Variable;
    comment fallback '= ' [my Variable Fallback] ' (append ' [my Variable Fallback] (i Fallback_Args) ');';
    python [my Variable Python] ' += ' (i Python_Args ' + ');
    javascript [my Variable Javascript] ' += ' (i Javascript_Args ' + ');
}

statement Debugger debugger Line
{
    method void Debug_Generate
    {
        string Code 'forever { = Exs (. Exc Interactive ' [my End_Line] '); breakif (isnull Exs); writeline (evaluate Exs); }';
        my= Debug Code;
    }
}

statement Entities entities Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between 'entity ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement My_Equal my= Assign
{
    alias my= self=;
    argument Property;
    argument Value;
    comment fallback '.= self ' [my Property Fallback] ' ' [my Value Fallback] ';';
    python 'self.' [my Property Python] ' = ' [my Value Python];
    javascript 'this.' [my Property Javascript] ' = ' [my Value Javascript] ';';
}

statement Integers 'integers' Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between 'integer ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement Return_If returnif Line
{
    alias return.if;
    argument Condition 'value';
    argument Return_Value 'value';
    python 'if ' [my Condition Python] ': return ' [my Return_Value Python];
    javascript 'if (' [my Condition Javascript] ') { return ' [my Return_Value Javascript] '; }';
}
statement New new Line;
statement Todo todo Comment
{
    fallback 'comment "TODO: "' (i Fallback_Args);
}

statement Write_Line writeline Append_Args
{
    python 'print(' (i Python_Args ',') ')';
    javascript 'console.log(' (i Javascript_Args ', ') ');';
    mumps 'write ' (i Mumps_Args ',') ',!';
}

syntax Repeating repeating;
syntax Optional optional;

operation M_Atom m.atom Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' M_Atom)';
}
operation M_Expr m.expr Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' M_Expr)';
}
operation Mumps mumps Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' Mumps)';
}
statement M_Atom m.atom Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' M_Atom ' [my Value Fallback] ';';
}
statement M_Expr m.expr Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' M_Expr ' [my Value Fallback] ';';
}
statement M m Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' Mumps ' [my Value Fallback] ';';
}

statement Unless unless If
{
    argument Condition;
    fallback 'if (not ' [my Condition Fallback] ')' (i Fallback_Block);
}

statement Symbol symbol Class
{
    argument Name;
    fallback 'class ' [my Name Fallback] 
        ' [is Symbol]'
        (i Fallback_Args) 
        (i Fallback_Block);
}

statement Spell spell Class
{
    alias protocol;
    argument Name;
    fallback 'class ' [my Name Fallback] 
        ' [is Spell]'
        (i Fallback_Args) 
        (i Fallback_Block);
}

statement Tilda ~ Invocation
{
    alias :;
    fallback '. ' (i Fallback_Args) ';';
}

operation Tilda ~ Invocation
{
    alias :;
    fallback '(. ' (i Fallback_Args) ')';
}

syntax Tilda ~
{
    alias :;
    fallback '[. ' (i Fallback_Args) ']';
}
